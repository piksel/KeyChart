// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
#pragma warning disable CS1591, CS1573, CS0465, CS0649, CS8019, CS1570, CS1584, CS1658
namespace Microsoft.Windows.Sdk
{
    using global::System;
    using global::System.Diagnostics;
    using global::System.Runtime.CompilerServices;
    using global::System.Runtime.InteropServices;

    /// <content>
    /// Contains extern methods from "User32.dll".
    /// </content>
    public static partial class PInvoke
    {
        /// <summary>Defines a system-wide hot key.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window that will receive <a href = "https://docs.microsoft.com/windows/desktop/inputdev/wm-hotkey">WM_HOTKEY</a> messages generated by the hot key. If this parameter is <b>NULL</b>, <b>WM_HOTKEY</b> messages are posted to the message queue of the calling thread and must be processed in the message loop.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerhotkey#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "id">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of the hot key.  If the <i>hWnd</i> parameter is NULL, then the hot key is associated with the current thread rather than with a particular window. If a hot key already exists with the same <i>hWnd</i> and <i>id</i> parameters, see Remarks for the action taken.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerhotkey#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "fsModifiers">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The keys that must be pressed in combination with the key specified by the</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerhotkey#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "vk">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The virtual-key code of the hot key. See <a href = "https://docs.microsoft.com/windows/desktop/inputdev/virtual-key-codes">Virtual Key Codes</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerhotkey#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-registerhotkey">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        public static extern bool RegisterHotKey(HWND hWnd, int id, RegisterHotKey_fsModifiersFlags fsModifiers, uint vk);
        /// <summary>Frees a hot key previously registered by the calling thread.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window associated with the hot key to be freed. This parameter should be <b>NULL</b> if the hot key is not associated with a window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unregisterhotkey#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "id">
        /// <para>Type: <b>int</b></para>
        /// <para>The identifier of the hot key to be freed.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unregisterhotkey#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-unregisterhotkey">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        public static extern bool UnregisterHotKey(HWND hWnd, int id);
        /// <inheritdoc cref = "FindWindow(PCWSTR, PCWSTR)"/>
        public static unsafe HWND FindWindow(string lpClassName, string lpWindowName)
        {
            fixed (char *lpWindowNameLocal = lpWindowName)
            {
                fixed (char *lpClassNameLocal = lpClassName)
                {
                    HWND __result = PInvoke.FindWindow(lpClassNameLocal, lpWindowNameLocal);
                    return __result;
                }
            }
        }

        /// <summary>Retrieves a handle to the top-level window whose class name and window name match the specified strings. This function does not search child windows. This function does not perform a case-sensitive search.</summary>
        /// <param name = "lpClassName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The class name or a class atom created by a previous call to the <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be in the low-order word of <i>lpClassName</i>; the high-order word must be zero.</para>
        /// <para>If <i>lpClassName</i> points to a string, it specifies the window class name. The class name can be any name registered with <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href = "https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a>, or any of the predefined control-class names.</para>
        /// <para>If <i>lpClassName</i> is <b>NULL</b>, it finds any window whose title matches the <i>lpWindowName</i> parameter.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-findwindoww#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lpWindowName">
        /// <para>Type: <b>LPCTSTR</b></para>
        /// <para>The window name (the window's title). If this parameter is <b>NULL</b>, all window names match.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-findwindoww#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>HWND</b></para>
        /// <para>If the function succeeds, the return value is a handle to the window that has the specified class name and window name.</para>
        /// <para>If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href = "/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-findwindoww">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "FindWindowW", SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        public static extern HWND FindWindow(PCWSTR lpClassName, PCWSTR lpWindowName);
        /// <summary>Sends the specified message to a window or windows. The SendMessage function calls the window procedure for the specified window and does not return until the window procedure has processed the message.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window whose window procedure will receive the message. If this parameter is <b>HWND_BROADCAST</b> ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.</para>
        /// <para>Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of lesser or equal integrity level.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "Msg">
        /// <para>Type: <b>UINT</b></para>
        /// <para>The message to be sent.</para>
        /// <para>For lists of the system-provided messages, see <a href = "https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "wParam">
        /// <para>Type: <b>WPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "lParam">
        /// <para>Type: <b>LPARAM</b></para>
        /// <para>Additional message-specific information.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>LRESULT</b></para>
        /// <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-sendmessagew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, EntryPoint = "SendMessageW", SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        public static extern LRESULT SendMessage(HWND hWnd, uint Msg, WPARAM wParam, LPARAM lParam);
        /// <summary>Sets the specified window's show state.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-showwindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "nCmdShow">Type: <b>int</b></param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the window was previously visible, the return value is nonzero.</para>
        /// <para>If the window was previously hidden, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-showwindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        public static extern bool ShowWindow(HWND hWnd, SHOW_WINDOW_CMD nCmdShow);
        /// <summary>Enables you to produce special effects when showing or hiding windows. There are four types of animation:\_roll, slide, collapse or expand, and alpha-blended fade.</summary>
        /// <param name = "hWnd">
        /// <para>Type: <b>HWND</b></para>
        /// <para>A handle to the window to animate. The calling thread must own this window.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-animatewindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwTime">
        /// <para>Type: <b>DWORD</b></para>
        /// <para>The time it takes to play the animation, in milliseconds. Typically, an animation takes 200 milliseconds to play.</para>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-animatewindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name = "dwFlags">Type: <b>DWORD</b></param>
        /// <returns>
        /// <para>Type: <b>BOOL</b></para>
        /// <para>If the function succeeds, the return value is nonzero.</para>
        /// <para>If the function fails, the return value is zero. The function will fail in the following situations:</para>
        /// <para></para>
        /// <para>This doc was truncated.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href = "https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-animatewindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("User32", ExactSpelling = true, SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        public static extern bool AnimateWindow(HWND hWnd, uint dwTime, AnimateWindow_dwFlags dwFlags);
    }

    /// <summary>
    /// A pointer to a constant character string.
    /// </summary>
    [DebuggerDisplay("{" + nameof(DebuggerDisplay) + "}")]
    public unsafe readonly partial struct PCWSTR : IEquatable<PCWSTR>
    {
        public readonly char *Value;
        public PCWSTR(char *value) => this.Value = value;
        public static explicit operator char *(PCWSTR value) => value.Value;
        public static implicit operator PCWSTR(char *value) => new PCWSTR(value);
        public static implicit operator PCWSTR(PWSTR value) => new PCWSTR(value.Value);
        public bool Equals(PCWSTR other) => this.Value == other.Value;
        public override bool Equals(object obj) => obj is PCWSTR other && this.Equals(other);
        public override int GetHashCode() => unchecked((int)this.Value);
        public int Length
        {
            get
            {
                char *p = this.Value;
                if (p is null)
                    return 0;
                while (*p != '\0')
                    p++;
                return checked((int)(p - this.Value));
            }
        }

        /// <summary>
        /// Returns a <see langword = "string"/> with a copy of this character array.
        /// </summary>
        /// <returns>A <see langword = "string"/>, or <see langword = "null"/> if <see cref = "Value"/> is <see langword = "null"/>.</returns>
        public override string ToString() => this.Value is null ? null : new string (this.Value);
        public ReadOnlySpan<char> AsSpan() => this.Value is null ? default(ReadOnlySpan<char>) : new ReadOnlySpan<char>(this.Value, this.Length);
        private string DebuggerDisplay => this.ToString();
    }

    [DebuggerDisplay("{Value}")]
    public readonly partial struct HWND : IEquatable<HWND>
    {
        public readonly nint Value;
        public HWND(nint value) => this.Value = value;
        public static implicit operator nint(HWND value) => value.Value;
        public static explicit operator HWND(nint value) => new HWND(value);
        public bool Equals(HWND other) => this.Value == other.Value;
        public override bool Equals(object obj) => obj is HWND other && this.Equals(other);
        public override int GetHashCode() => this.Value.GetHashCode();
    }

    [Flags]
    public enum RegisterHotKey_fsModifiersFlags : uint
    {
        MOD_ALT = 0x00000001,
        MOD_CONTROL = 0x00000002,
        MOD_NOREPEAT = 0x00004000,
        MOD_SHIFT = 0x00000004,
        MOD_WIN = 0x00000008,
    }

    [DebuggerDisplay("{Value}")]
    public unsafe readonly partial struct PWSTR : IEquatable<PWSTR>
    {
        public readonly char *Value;
        public PWSTR(char *value) => this.Value = value;
        public static implicit operator char *(PWSTR value) => value.Value;
        public static implicit operator PWSTR(char *value) => new PWSTR(value);
        public bool Equals(PWSTR other) => this.Value == other.Value;
        public override bool Equals(object obj) => obj is PWSTR other && this.Equals(other);
        public override int GetHashCode() => unchecked((int)this.Value);
        public int Length
        {
            get
            {
                char *p = this.Value;
                if (p is null)
                    return 0;
                while (*p != '\0')
                    p++;
                return checked((int)(p - this.Value));
            }
        }

        public override string ToString() => this.Value is null ? null : new string (this.Value);
        public Span<char> AsSpan() => this.Value is null ? default(Span<char>) : new Span<char>(this.Value, this.Length);
    }

    [DebuggerDisplay("{Value}")]
    public readonly partial struct LRESULT : IEquatable<LRESULT>
    {
        public readonly int Value;
        public LRESULT(int value) => this.Value = value;
        public static implicit operator int (LRESULT value) => value.Value;
        public static explicit operator LRESULT(int value) => new LRESULT(value);
        public bool Equals(LRESULT other) => this.Value == other.Value;
        public override bool Equals(object obj) => obj is LRESULT other && this.Equals(other);
        public override int GetHashCode() => this.Value.GetHashCode();
    }

    [DebuggerDisplay("{Value}")]
    public readonly partial struct WPARAM : IEquatable<WPARAM>
    {
        public readonly nuint Value;
        public WPARAM(nuint value) => this.Value = value;
        public static implicit operator nuint(WPARAM value) => value.Value;
        public static explicit operator WPARAM(nuint value) => new WPARAM(value);
        public bool Equals(WPARAM other) => this.Value == other.Value;
        public override bool Equals(object obj) => obj is WPARAM other && this.Equals(other);
        public override int GetHashCode() => this.Value.GetHashCode();
    }

    [DebuggerDisplay("{Value}")]
    public readonly partial struct LPARAM : IEquatable<LPARAM>
    {
        public readonly nint Value;
        public LPARAM(nint value) => this.Value = value;
        public static implicit operator nint(LPARAM value) => value.Value;
        public static explicit operator LPARAM(nint value) => new LPARAM(value);
        public bool Equals(LPARAM other) => this.Value == other.Value;
        public override bool Equals(object obj) => obj is LPARAM other && this.Equals(other);
        public override int GetHashCode() => this.Value.GetHashCode();
    }

    [Flags]
    public enum SHOW_WINDOW_CMD : uint
    {
        SW_HIDE = 0x00000000,
        SW_FORCEMINIMIZE = 0x0000000B,
        SW_MAXIMIZE = 0x00000003,
        SW_MINIMIZE = 0x00000006,
        SW_RESTORE = 0x00000009,
        SW_SHOW = 0x00000005,
        SW_SHOWDEFAULT = 0x0000000A,
        SW_SHOWMAXIMIZED = 0x00000003,
        SW_SHOWMINIMIZED = 0x00000002,
        SW_SHOWMINNOACTIVE = 0x00000007,
        SW_SHOWNA = 0x00000008,
        SW_SHOWNOACTIVATE = 0x00000004,
        SW_SHOWNORMAL = 0x00000001,
        SW_NORMAL = 0x00000001,
        SW_MAX = 0x0000000B,
        SW_PARENTCLOSING = 0x00000001,
        SW_OTHERZOOM = 0x00000002,
        SW_PARENTOPENING = 0x00000003,
        SW_OTHERUNZOOM = 0x00000004,
        SW_SCROLLCHILDREN = 0x00000001,
        SW_ERASE = 0x00000004,
        SW_INVALIDATE = 0x00000002,
        SW_SMOOTHSCROLL = 0x00000010,
    }

    [Flags]
    public enum AnimateWindow_dwFlags : uint
    {
        AW_ACTIVATE = 0x00020000,
        AW_BLEND = 0x00080000,
        AW_CENTER = 0x00000010,
        AW_HIDE = 0x00010000,
        AW_HOR_POSITIVE = 0x00000001,
        AW_HOR_NEGATIVE = 0x00000002,
        AW_SLIDE = 0x00040000,
        AW_VER_POSITIVE = 0x00000004,
        AW_VER_NEGATIVE = 0x00000008,
    }
}